---
title: "Donnees AMR"
author: "Valentine BERTHIER"
date: "2024-01-14"
output: html_document
bibliography : projet-stat-2A.bib
---

```{r setup,echo=FALSE,include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(readxl)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(rstatix)

rm(list=ls())
```

Essayons de mettre en forme ce fichier avec chaque analyse que nous trouvons vraiment indispensable. Il faudrait que ce fichier ne contienne que les graphiques permettant la validation de l'indicateur.

# INTRODUCTION DE LA PARTIE ANALYSE

## Importation des données et transformation des variables

### Données de pan-sensbilité
```{r,echo=FALSE, include=FALSE}
AMR <- read_excel("donnees/donnees_AMR.xlsx")

# On renomme "bovin-abattoir" en "veau-abattoir"
AMR$population <- ifelse(AMR$population == "bovin-abattoir", "veau-abattoir", AMR$population)

# Séparation en 2 familles
AMR_humaine <- AMR[which(AMR$famille=='humaine'),]
AMR_animale <- AMR[which(AMR$famille=='animale'),]

AMR_nationale <- AMR %>%
  filter(region == "Nationale")
AMR_regionale <- AMR %>%
  filter(region != "Nationale")

AMR_nationale_animal <- AMR_nationale %>%
  filter(famille == "animale")
AMR_nationale_humain <- AMR_nationale %>%
  filter(famille == "humaine")

# Identification et suppression des valeurs aberrantes
AMR_humaine %>%
  identify_outliers(`valeur AMR`)
AMR_humaine <- AMR_humaine[-c(262),]

# Indicatrice selon que la population provient d'un abattoir ou non
AMR_nationale_animal$abattoir <- grepl("abattoir", AMR_nationale_animal$population, ignore.case = TRUE)

AMR$famille2 <- paste(AMR$famille, ifelse(grepl("abattoir", AMR$population, ignore.case = TRUE), "-abattoir", ""), sep = "")

AMR_regionale$famille2 <- paste(AMR_regionale$famille, ifelse(grepl("abattoir", AMR_regionale$population, ignore.case = TRUE), "-abattoir", ""), sep = "")
```

### Données Résapath effectif de pan-sensibles

```{r}
# Données permettant d'étudier la perte animale d'effectif des pan-sensibles
ResapathFrance <- read_xlsx("donnees/ModeleCollecte_PROMISE_ResapathFrance.xlsx",sheet = "Modele de collecte")

# Uniformisation entre les différentes tables
ResapathFrance <- ResapathFrance%>%
  mutate(population = as.factor(population),
         `profil AMR`= as.factor(`profil AMR`),
         region = as.factor(region))

# On retire les observations SARM (ça supprime aussi les lignes vide)
ResapathFrance_sansSARM <- ResapathFrance%>%
  filter(`profil AMR` != "SARM", bacterie == "Escherichia coli")

# Dans ModeleHUM1, on observe les données de la population : EHPAD et ville
ModeleHUM1 <- read_xlsx(
  "donnees/ModeleCollecte_PROMISE_MedQual-2012-2017.xlsx",
  sheet = "Modele de collecte", #nom de la page à garder
)
ModeleHUM1<-ModeleHUM1%>%
  mutate(population=as.factor(population),`profil AMR`=as.factor(`profil AMR`))

# Dans ModeleHUM1, on observe les données de la population : ES et ES-hemoculture
ModeleHUM2 <- read_xlsx(
  "donnees/SPARES_Donnees AMR_08122022.xlsx",
  sheet = "Modele de collecte", #nom de la page à garder
)
ModeleHUM2<-ModeleHUM2%>%
  mutate(population=as.factor(population),`profil AMR`=as.factor(`profil AMR`))
```

### Données d'usage

```{r}
usage <- read_excel("donnees/D_usage.xlsx")

usage$population <- as.factor(usage$population)
usage_animal <- usage %>%
  filter(famille == "Animale") %>%
  arrange(population, -annee)
usage_humain <- usage %>%
  filter(famille == "Humaine") %>%
  select(population, annee, region, `valeur AMU`) %>%
  left_join(AMR_humaine[,-c(1, 4)], by = join_by(region, annee, population)) %>%
  arrange(population, -annee)
```

### Transformation pour la cartographie

```{r}
# On ne s'intéresse quà 3 extraits de données

AMR_ville_2021<-AMR%>%
  filter(population=="ville",annee=="2021")

AMR_bovin_2021<-AMR%>%
  filter(population=="bovin-adulte",annee=="2021")

AMR_chat_2021<-AMR%>%
  filter(population=="Chat",annee=="2021")

# chargement des tracés des régions
reg_2019<-read.csv("donnees/region2019.csv") # données externes d'infos sur les régions
load("donnees/reg_metropole.rdata") 
```


## Analyse descriptive

Nous recherchons une liaison entre une variable qualitative (la population) et une variable quantitative (la valeur AMR). Pour cela, un boxplot permet d'avoir un premier aperçu des ressemblances.

```{r,echo=FALSE}
label <- c("Veau", "Lapin", "Poulet", "Porc", "Volaille", "Dinde", "Caprin", "EHPAD", "Veau", "ES-hemoculture", "Ovin", "ES", "Porc", "Ville", "Cheval","Volaille", "Chien", "Bovin", "Chat")

ggplot(AMR_regionale, aes(x = `valeur AMR`, y = reorder(population, `valeur AMR`, mean), fill = famille2))+
  geom_boxplot()+
  labs(title = "Des résultats dispersés pour toutes les populations",
       subtitle = "Comparaison des valeurs Pan-S entre animaux et humains",
       caption = "Note: Chaque ligne de données correspond à une région et une année",
       y = NULL,
       x = "AMR moyen",
       x = "Valeur Pan-S",
       fill = "Famille")+
  theme_minimal()+
  scale_fill_manual(values = c("#90fc9b", "#4b9c4f", "#fa9c43"))+
  scale_y_discrete(labels = label)

label <- c("Veau", "Lapin", "Porc", "Poulet", "Volaille", "Dinde", "Caprin", "EHPAD", "Veau", "ES-hemoculture", "Ovin", "ES", "Porc","Dinde", "Ville", "Cheval", "Volaille", "Chien", "Poulet", "Bovin", "Chat")

ggplot(AMR, aes(x = `valeur AMR`, y = reorder(population, `valeur AMR`, mean), fill = famille2))+
  geom_boxplot()+
  labs(title = "Des résultats dispersés pour toutes les populations",
       subtitle = "Comparaison des valeurs Pan-S entre animaux et humains (France entière ajoutée)",
       caption = "Note: Chaque ligne de données correspond à une région ou la france entière et une année",
       y = NULL,
       x = "Valeur Pan-S",
       fill = "Famille")+
  theme_minimal()+
  scale_fill_manual(values = c("#90fc9b", "#4b9c4f", "#fa9c43"))+
  scale_y_discrete(labels = label)
```
Sur ce graphique nous avons ajouté la répartition des familles qui permet d'avoir un premier aperçu sur les valeurs AMR humaines par rapport à animales.

Nous pouvons observer que les animaux "domestiques" (Chien, chat, cheval) ont une plus grande sensibilité que les animaux dits de "production" (volaille-abattoir, bovin-abattoir, poulet-abattoir) qui ont tendance à plus apparaître vers les faibles valeurs de sensibilité.

# VALIDATION DE LA PAN-S

## Propriétés de l'indicateur

### Possibilité de calcul de la pan-S

Taille du jeu de données (nombre moyen d’isolats considérés)
Il s’agit ici de montrer que la proportion de pan-sensibles est calculable pour toutes les populations. Et que la perte d’information liée aux souches pour lesquelles ce n’est pas calculable est restreinte. -> présentation d’un boxplot des taux de calcul par espèce/population 

#### 1 : Taille du jeu de données
```{r echo=TRUE}
print(paste("nombre moyen d'isolats considérés en France entière: ", round(mean(AMR_nationale$`effectif AMR`), 0)))
print(paste("nombre moyen d'isolats considérés en découpage par région: ", round(mean(AMR_regionale$`effectif AMR`), 0)))

AMR %>%
  group_by(population, annee, region) %>%
  summarise(`nombre moyen d'isolats` = round(mean(`effectif AMR`), 0))%>%
  arrange(desc(`nombre moyen d'isolats`))
AMR %>%
  group_by(population) %>%
  summarise(`nombre de régions` = n_distinct(region)-1)%>%
arrange(desc(`nombre de régions`))
```

Par population et année, il y a, en moyenne, 24331 isolats. Plus on avance dans le temps, plus on a d'isolats considérés dans les analyses.

```{r,echo=FALSE}
effectif_national <- AMR %>%
  filter(region == "Nationale") %>%
  select(annee, population, `effectif AMR`) %>%
  summarise(effectif_national = sum(`effectif AMR`), .by = c(annee, population))

effectif_regional <- AMR %>%
  filter(region != "Nationale") %>%
  select(annee, population, `effectif AMR`) %>%
  summarise(effectif_regional = sum(`effectif AMR`), .by = c(annee, population))

AMR_perte_regionale <- full_join(effectif_national, effectif_regional)

AMR_perte_regionale_animal <- AMR_perte_regionale %>%
  mutate(perte = 1 - effectif_regional/effectif_national) %>%
  filter(!is.na(perte))%>%
  filter(!(population %in% c("ville", "EHPAD", "ES", "ES-hemoculture")))

AMR_perte_regionale_humain <- AMR_perte_regionale %>%
  mutate(perte = 1 - effectif_regional/effectif_national) %>%
  filter(!is.na(perte))%>%
  filter(population %in% c("ville", "EHPAD", "ES", "ES-hemoculture"))

rm(AMR_perte_regionale, effectif_regional, effectif_national)
  
label <- c("Chien", "Veau", "Chat", "Bovin", "Cheval", "Volaille-abattoir", "Dinde-abattoir", "Lapin", "Porc", "Porc-abattoir", "Poulet-abattoir", "Veau-abattoir")

ggplot(AMR_perte_regionale_animal, aes(x = reorder(population, perte), y = perte)) +
  geom_boxplot() +
  geom_hline(yintercept = mean(AMR_perte_regionale_animal$perte), color = "darkgreen", size = 0.8, linetype = "dashed") +
  labs(title = "Perte d'effectif lors du passage de l'échelle nationale à régionale",
       x = NULL,
       y = "Taux d'effectif perdu",
       caption = str_glue("Cohorte : population animale\nLecture : Entre 2012 et 2021, 50% des années ont fait face à une perte régionale d'au moins 50% pour la population des porcs."))+
  scale_y_continuous(labels = scales::label_percent(scale = 100))+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  annotate("text", x = 11, y = 0.18, label = "Mean = 23.54%", colour = "darkgreen", size = 3.3)+
  scale_x_discrete(labels = label)

ggplot(AMR_perte_regionale_humain, aes(x = reorder(population, perte), y = perte)) +
  geom_hline(yintercept = mean(AMR_perte_regionale_humain$perte), color = "darkgreen", size = 0.8, linetype = "dashed") +
  geom_boxplot(na.rm = TRUE) +
  labs(title = "Perte d'effectif lors du passage de l'échelle nationale à régionale",
       x = NULL,
       y = "Taux d'effectif perdu",
       caption = str_glue("Cohorte : population humaine\nLecture : Entre 2012 et 2021, les isolats humains ont subi moins de 1% de perte au niveau régional."))+
  scale_y_continuous(labels = scales::label_percent(scale = 100), limits = c(0,0.01))+
  annotate("text", x = 0.7, y = 0.0014, label = "Mean = 0.09%", colour = "darkgreen", size = 3.3)+
  scale_x_discrete(labels = c("ES", "ES-hemoculture", "Ville", "EHPAD"))
```
La différence entre les effectifs nationaux et régionaux pour les population humaines sont de l'ordre de 1% et constitue donc une part négligeable à l'étude. L'étude au niveau régionale ne constitue donc pas un risque en terme de perte d'information. Pour les populations animales, la perte est assez élevée donc une étude régionale constitue un risque de perte d'informations. 

#### 2 : Perte d’information liée aux souches pour lesquelles ce n’est pas calculable

```{r,echo=FALSE}
table1 <- ResapathFrance_sansSARM %>%
  filter(`profil AMR` == "pan-sensible") %>%
  mutate(eff_pansensible = `effectif AMR`) %>%
  select(annee, population, eff_pansensible)

table2 <- ResapathFrance_sansSARM %>%
  filter(`profil AMR` == "C3G-R") %>%
  mutate(eff_C3G = `effectif AMR`) %>%
  select(annee, population, eff_C3G)

table_join <- merge(table1, table2, by = c("annee", "population"), all = TRUE)

table_join<-table_join%>%
  mutate(taux=(eff_pansensible/eff_C3G)*100)

label <- c("Veau", "Chat", "Chien", "Cheval", "Bovin", "Porc", "Poulet", "Dinde", "Lapin")

ggplot(table_join, aes(x = reorder(population, -taux), y = 100-taux)) +
  geom_boxplot() +
  geom_hline(yintercept = 100 - mean(table_join$taux), color = "darkgreen", linetype = "dashed", size = 0.8) +
  labs(title = "Variation de la fraction d'isolats bactériens pour lesquels la pan-sensibilité\n n'a pas pu être calculée au sein de chaque population étudiée",
       x = NULL,
       y = "Taux de perte",
       caption = str_glue("Cohorte : population animale au niveau national\nLecture : En moyenne, 13 % des animaux étudiés n'ont pas un profil de résistance pan-sensible."))+
  scale_y_continuous(labels =scales::number_format(suffix=" %"),limits=c(0,100))+
  scale_x_discrete(labels = label)+
  annotate("text", x = 1.5, y = 18.5, label = "Mean = 13.2%", colour = "darkgreen", size = 3.3)
```

```{r}
table1 <- ModeleHUM1 %>%
  filter(`profil AMR` == "pan-sensible", bacterie=="Escherichia coli") %>%
  group_by(annee, population, region)%>%
  mutate(eff_pansensible=sum(`effectif AMR`))%>%
  select(annee, population, region, eff_pansensible)
table2 <- ModeleHUM1 %>%
  filter(`profil AMR` == "C3G-R",bacterie=="Escherichia coli") %>%
  group_by(annee, population, region)%>%
  mutate(eff_C3G=sum(`effectif AMR`))%>%
  select(annee, population, region, eff_C3G)

table3 <- ModeleHUM2 %>%
  filter(`profil AMR` == "pan-sensible",bacterie=="Escherichia coli") %>%
  group_by(annee, population, region)%>%
  mutate(eff_pansensible=sum(`effectif AMR`))%>%
  select(annee, population, region, eff_pansensible)
table4 <- ModeleHUM2 %>%
  filter(`profil AMR` == "C3G-R",bacterie=="Escherichia coli") %>%
  group_by(annee, population, region)%>%
  mutate(eff_C3G=sum(`effectif AMR`))%>%
  select(annee, population, region, eff_C3G)

tableX <- merge(table1, table2, by = c("annee", "population","region"), all = TRUE)
tableY <- merge(table3, table4, by = c("annee", "population","region"), all = TRUE)
table <- rbind(tableX,tableY)

rm(table1, table2, table3, table4, tableX, tableY)

table<-table%>%
  mutate(taux=(eff_pansensible/eff_C3G)*100)

moyenne<-mean(table$taux,na.rm = TRUE) 

ggplot(table, aes(x = reorder(population, -taux), y = 100-taux)) +
  geom_boxplot() +
  geom_hline(yintercept = 100 - moyenne, color = "darkgreen", linetype = "dashed", size = 0.8) +
  labs(title = "Variation de la fraction d'isolats bactériens pour lesquels la pan-sensibilité n'a pas\npu être calculée au sein de chaque population étudiée",
       x = NULL,
       y = "Taux de perte",
       caption = str_glue("Cohorte : population humaine au niveau régional\nLecture : En moyenne, 6.4% des humains étudiés n'ont pas un profil de résistance pan-sensible."))+
  scale_y_continuous(labels =scales::number_format(suffix=" %"),limits=c(0,100))+
  scale_x_discrete(labels = population)+
  annotate("text", x = 0.7, y = 4, label = paste0("Mean = ", round(100-moyenne, 1), "%"), colour = "darkgreen", size = 3.3)
```

#### 3 : Test de proportion

```{r}
if(!require("plyr")){
  install.packages("plyr")
  require("plyr")
}

# Calculer la moyenne
proportion_obs <- (100 - mean(table_join$taux))/100

# On spécifie la proportion qu'on souhaite tester (20%)
proportion_nulle <- 20/100

# Calculer la statistique de test z
z_stat <- (proportion_obs - proportion_nulle) / sqrt(proportion_nulle * (1 - proportion_nulle) / nrow(table_join))

# Calculer la valeur p pour un test unilatéral à gauche
p_value <- pnorm(z_stat)

print("animaux")
cat("Proportion observée:", proportion_obs, "\n")
cat("Statistique de test z:", z_stat, "\n")
cat("P-valeur:", p_value, "\n")

proportion_obs <- (100 - mean(table$taux, na.rm = TRUE))/100
proportion_nulle <- 15/100
z_stat <- (proportion_obs - proportion_nulle) / sqrt(proportion_nulle * (1 - proportion_nulle) / nrow(table_join))
p_value <- pnorm(z_stat)
print("humains")
cat("Proportion observée:", proportion_obs, "\n")
cat("Statistique de test z:", z_stat, "\n")
cat("P-valeur:", p_value, "\n")
```
Avec un niveau de confiance de 94%, on peut conclure que la proportion de perte pour chaque isolat animal est significativement inférieure à 20%. Pour la famille humaine, nous pouvons conclure, au niveau de confiance de 99% que la proportion de perte dûe aux tests de pan-sensibilité est significativement inférieure à 15%.

### Validité de l'information

Comparer ici les valeurs pan-S si on rajoute les tetracyclines chez animal ou colistine ou carbapenemes chez homme ->est-ce que valeur change beaucoup. Pas faisable pour toutes sources de données mais ok pour Resapath et LNR chez l’animal.

### Variabilité des données : sont-elles assez contrastées ?

représenter des boxplots par population des estimations régionales annuelles (ou toute autre représentation type violinplot, raincloud plot ou autre). -> pour montrer qu'il y a de la variabilité.
Représenter des cartes (dernière année par exemple pour homme et/ou carnivores ou bovins) pour illustrer variabilité géographique.
Faire une estimation des facteurs de variation (entre année, région, population). (analyse de variance)

#### 1 : Variabilité par population

La variabilité entre les populations a déjà pu être observée dans l'analyse descriptive, concentrons-nous sur l'étude de l'homogénéité des variances et des moyennes par groupe.

```{r}
# Test de levene d'égalité de variance des valeurs de pan-S entre les années (H0: variances égales)
AMR_humaine %>% levene_test(`valeur AMR` ~ population)
AMR_animale %>% levene_test(`valeur AMR` ~ population)
```
Pour les 2 familles, la p-valeur<0.05, on rejete l'hypothèse nulle, ainsi nous observons une différence significative entre les variances de la pan-S par population. Par conséquent, nous ne pouvons pas supposer l’homogénéité des variances parmi les différentes populations étudiées.

#### 2 : Variabilité annuelle
+ test d'égalité des moyennes (student ?)
L'Anova généralise le test de Student de comparaison de deux moyennes, à la comparaison de moyennes de plusieurs groupes.

```{r,echo=FALSE}
AMR_animale$annee <- as.factor(AMR_animale$annee)
AMR_humaine$annee <- as.factor(AMR_humaine$annee)

ggplot(AMR_animale, aes(x = `valeur AMR`, y = annee)) +
  geom_boxplot() +
  labs(title = "Distribution de la pan-sensibilité par année pour les animaux",
       x = "Pan-sensibilité",
       y = NULL) +
  theme_minimal()

ggplot(AMR_humaine, aes(x = `valeur AMR`, y = annee)) +
  geom_boxplot() +
  labs(title = "Distribution de la pan-sensibilité par année pour les humains",
       x = "Pan-sensibilité",
       y = NULL, 
       caption = "Uniquement les données régionales") +
  theme_minimal() 

# Test de levene d'égalité de variance des valeurs de pan-S entre les années (H0: variances égales)
AMR_humaine %>% levene_test(`valeur AMR` ~ annee)
AMR_animale %>% levene_test(`valeur AMR` ~ annee)
```
Pour les 2 familles, la p-valeur>0.05, on ne peux pas rejeter l'hypothèse nulle, ainsi nous n'observons pas de différence significative entre les variances des données annuelles. Par conséquent, nous pouvons supposer l’homogénéité des variances parmi les différentes années d'étude.

#### 3 : Variabilité entre les régions
+ test d'égalité des moyennes (student ?)

```{r}
# Test de levene d'égalité de variance entre les régions (H0: variances égales)
AMR_humaine %>% levene_test(`valeur AMR` ~ region)
AMR_animale %>% levene_test(`valeur AMR` ~ region)

# Représentation de la variabilité entre les régions
ggplot(AMR_animale, aes(x = `valeur AMR`, y = region)) +
  geom_boxplot() +
  labs(title = "Distribution de l'AMR par région pour les animaux",
       x = "Valeur de l'AMR",
       y = "Région") +
  theme_minimal()
ggplot(AMR_humaine, aes(x = `valeur AMR`, y = region)) +
  geom_boxplot() +
  labs(title = "Distribution de l'AMR par région pour les humains",
       x = "Valeur de l'AMR",
       y = "Région") +
  theme_minimal()
```
Les variances régionales de la pan-S sont significativements différentes pour les populations animales mais par pour les humains. C'est assez contraire à ce que nous disais Mme Chauvin.

```{r}
# Cartographie des résultats de pan-S en ville

# ETAPE 1 : on récupère les régions où la valeur AMR a été calculée
regions<-data.frame(unique(AMR_ville_2021$region))
names(regions)<-"libelle"

# ETAPE 2 : jointure pour faire correspondre code et region
regions_code<-full_join(regions, as.data.frame(reg_2019), by = "libelle")
regions_code<-regions_code%>%
  select(libelle,reg)

# ETAPE 3 : jointure avec les codes régionaux

library(sf)
regions_code_poly<-right_join(regions_code, st_as_sf(reg_metropole), by = "reg")
regions_code_poly<-regions_code_poly%>%
  rename(region=libelle)

# ETAPE 4 : jointure finale
regions_AMR_ville<-AMR_ville_2021%>%
  right_join(regions_code_poly,by = join_by(region))%>%
  select(region,`valeur AMR`,geometry)

# ETAPE 5 : on retire les régions dont on ne dispose pas les formes géométriques et la valeur nationale
R1_Guad<-regions_AMR_ville[7,]
R1_Mart<-regions_AMR_ville[10,]
R1_Guyane<-regions_AMR_ville[16,]
R1_Reunion<-regions_AMR_ville[17,]
R1_Mayotte<-regions_AMR_ville[18,]

R1<-regions_AMR_ville[-c(7,10,16,17,18),]

# Représentation de la valeur AMR de la population ville en 2021 

carteAMR1<-R1%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), # on supprime les petits tirets des axes
        panel.grid.major = element_blank(), # on supprime la grille
        panel.grid.minor = element_blank(), # on supprime la grille
        panel.background = element_blank()) + 
  labs(title = "Pan-sensibilité de la population ville en France en 2021",
       fill = "Pan-sensibilité")
carteAMR1_Guad<-R1_Guad%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mart<-R1_Mart%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mayotte<-R1_Mayotte%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Guyane<-R1_Guyane%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Reunion<-R1_Reunion%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank()+ theme(legend.position = "none"))

if(!require("patchwork")){
  install.packages("patchwork")
  library("patchwork")
}

carteAMR1 / ((carteAMR1_Mart / carteAMR1_Mayotte) | (carteAMR1_Guyane / carteAMR1_Reunion / carteAMR1_Guad))

# Cartographie des résultats de pan-S pour les bovins

# ETAPE 1 : on récupère les régions où la valeur AMR a été calculée
regions<-data.frame(unique(AMR_bovin_2021$region))
names(regions)<-"libelle"

# ETAPE 2 : jointure pour faire correspondre code et region
regions_code<-full_join(regions, reg_2019, by = "libelle")
regions_code<-regions_code%>%
  select(libelle,reg)

# ETAPE 3 : jointure avec les codes régionaux
regions_code_poly<-right_join(regions_code, reg_metropole, by = "reg")
regions_code_poly<-regions_code_poly%>%
  rename(region=libelle)

# ETAPE 4 : jointure finale
regions_AMR_bovin<-AMR_bovin_2021%>%
  right_join(regions_code_poly,by = join_by(region))%>%
  select(region,`valeur AMR`,geometry)

# ETAPE 5 : on retire les régions dont on ne dispose pas les formes géométriques et la valeur nationale
R1_Guad<-regions_AMR_bovin[10,]
R1_Mart<-regions_AMR_bovin[11,]
R1_Réunion<-regions_AMR_bovin[13,]
R1_Guyane<-regions_AMR_bovin[12,]
R1_Mayotte<-regions_AMR_bovin[14,]

R1<-regions_AMR_bovin[-c(10,11,12,13,14),] 

# Représentation de la valeur AMR de la population bovin en 2021 

carteAMR1<-R1%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), # on supprime les petits tirets des axes
        panel.grid.major = element_blank(), # on supprime la grille
        panel.grid.minor = element_blank(), # on supprime la grille
        panel.background = element_blank()) + 
  labs(title = "Pan-sensibilité de la population bovin en France en 2021",
       fill = "Pan-sensibilité")
carteAMR1_Guad<-R1_Guad%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mart<-R1_Mart%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mayotte<-R1_Mayotte%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Guyane<-R1_Guyane%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Reunion<-R1_Reunion%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank()+ theme(legend.position = "none"))

carteAMR1 / ((carteAMR1_Mart / carteAMR1_Mayotte) | (carteAMR1_Guyane / carteAMR1_Reunion / carteAMR1_Guad))

# Cartographie des résultats de pan-S pour les chats et chiens

# ETAPE 1 : on récupère les régions où la valeur AMR a été calculée
regions<-data.frame(unique(AMR_chat_2021$region))
names(regions)<-"libelle"

# ETAPE 2 : jointure pour faire correspondre code et region
regions_code<-full_join(regions, reg_2019, by = "libelle")
regions_code<-regions_code%>%
  select(libelle,reg)

# ETAPE 3 : jointure avec les codes régionaux
regions_code_poly<-right_join(regions_code, reg_metropole, by = "reg")
regions_code_poly<-regions_code_poly%>%
  rename(region=libelle)

# ETAPE 4 : jointure finale
regions_AMR_chienchat<-AMR_chat_2021%>%
  right_join(regions_code_poly,by = join_by(region))%>%
  select(region,`valeur AMR`,geometry)

# ETAPE 5 : on retire les régions dont on ne dispose pas les formes géométriques et la valeur nationale
R1_Guad<-regions_AMR_chienchat[10,]
R1_Mart<-regions_AMR_chienchat[11,]
R1_Guyane<-regions_AMR_chienchat[12,]
R1_Réunion<-regions_AMR_chienchat[13,]
R1_Mayotte<-regions_AMR_chienchat[14,]

R1<-regions_AMR_chienchat[-c(10,11,12,13,14),]

# Représentation de la valeur AMR de la population bovin en 2021 

carteAMR1<-R1%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), # on supprime les petits tirets des axes
        panel.grid.major = element_blank(), # on supprime la grille
        panel.grid.minor = element_blank(), # on supprime la grille
        panel.background = element_blank()) + 
  labs(title = "Pan-sensibilité de la population chien/chat en France en 2021",
       fill = "Pan-sensibilité")
carteAMR1_Guad<-R1_Guad%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mart<-R1_Mart%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Mayotte<-R1_Mayotte%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Guyane<-R1_Guyane%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),legend.position = "none")
carteAMR1_Reunion<-R1_Reunion%>%
  ggplot() +
  geom_sf(aes(geometry=geometry,fill=`valeur AMR`))+
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank()+ theme(legend.position = "none"))

carteAMR1 / ((carteAMR1_Mart / carteAMR1_Mayotte) | (carteAMR1_Guyane / carteAMR1_Reunion / carteAMR1_Guad))
```

#### 4 : L'analyse de variance

#### Humain

```{r}
data_anova <- AMR_humaine %>%
  select(annee, population, region, `valeur AMR`) %>%
  filter(region != "Nationale") # On supprime les données nationales pour permettre d'insérer le regroupement régional dans l'analyse

data_anova$population <- as.factor(data_anova$population)
data_anova$region <- as.factor(data_anova$region)
data_anova$annee <- as.factor(data_anova$annee)

# Les hypothèses à vérifier avant l'anova

## 1 - Identification des éventuelles valeurs aberrantes
data_anova %>%
  identify_outliers(`valeur AMR`) # Aberrante mais pas extrême donc on peut la garder, c'est la valeur pour la Guadeloupe qui est un cas particulier de base

## 2 - Hypothèse de normalité
model_pop <- lm(`valeur AMR` ~ population, data = data_anova)
ggpubr::ggqqplot(residuals(model_pop))
model_reg <- lm(`valeur AMR` ~ region, data = data_anova)
ggpubr::ggqqplot(residuals(model_reg))
model_annee <- lm(`valeur AMR` ~ annee, data = data_anova)
ggpubr::ggqqplot(residuals(model_annee))# Sur le qqplot, les points sont, en grande partie, alignés avec la première bissectrice, on suppose l'hypothèse de normalité vérifiée

## 3 - Hypothèse d’homogénéité des variances
# Hypothèse vérifiée pour la variable annee mais pas pour la variable region. Les résultats devront être interprétés par conséquent. De même, l'hypothèse d'homogénéité des variances n'est pas vérifiée pour des populations différentes.

# Calculer les parts de variance associée à la variance totale.
anova_test(`valeur AMR` ~ population + region + annee, data = data_anova)
```
La variable qui apporte le plus de variabilité au sein des données de pan-S humaines est la population (66 %), puis la région (54 %) et l'année (qui explique seulement 32 % de la variabilité). Cela n'est pas en accord avec ce qu'avait supposé Mme. Chauvin. On observe tout de même une grande part de variabilité dûe aux régions en comparaison avec l'anova sur les animaux.

#### Animal

```{r}
data_anova <- AMR_animale %>%
  select(annee, population, region, `valeur AMR`) %>%
  filter(region != "Nationale") # On supprime les données nationales pour permettre d'insérer le regroupement régional dans l'analyse

data_anova$population <- as.factor(data_anova$population)
data_anova$region <- as.factor(data_anova$region)
data_anova$annee <- as.factor(data_anova$annee)

# Les hypothèses à vérifier avant l'anova

## 1 - Identification des éventuelles valeurs aberrantes
data_anova %>%
  identify_outliers(`valeur AMR`) # Pas de valeur aberrante

## 2 - Hypothèse de normalité
model_pop <- lm(`valeur AMR` ~ population, data = data_anova)
ggpubr::ggqqplot(residuals(model_pop))
model_reg <- lm(`valeur AMR` ~ region, data = data_anova)
ggpubr::ggqqplot(residuals(model_reg))
model_annee <- lm(`valeur AMR` ~ annee, data = data_anova)
ggpubr::ggqqplot(residuals(model_annee))# Sur le qqplot, les points sont, en grande partie, alignés avec la première bissectrice, on suppose l'hypothèse de normalité vérifiée

## 3 - Hypothèse d’homogénéité des variances
# Hypothèse vérifiée pour les variables annees et regions dans les parties 1 et 2 du critère

# Calculer les parts de variance associée à la variance totale.
anova_test(`valeur AMR` ~ population + region + annee, data = data_anova)
```

Nous obtenons plus ou moins les nênes résultats, l'année n'explique que très peu la variabilité des données alors que la population explique la quasi totalité de la variabilité de la pan-S dans la famille animale.

## Points d'intérêt de l'indicateur

### Identification de tendances

Spageti plot et tests de tendance -> pour montrer que des tendances identifiables

```{r,echo=FALSE}
ggplot(AMR_nationale_animal[which(AMR_nationale_animal$abattoir == TRUE),], aes(x = annee, y = `valeur AMR`, group = population, color = population)) +
  geom_line(stat = "summary", fun = "mean") +
  geom_point(stat = "summary", fun = "mean", size = 2) +
  labs(title = "Hausse générale de la sensibilité des populations en abattoir",
       x = NULL,
       y = "Pan-sensibilité moyenne",
       color = "Population") +
  theme_minimal()

ggplot(AMR_nationale_animal[which(AMR_nationale_animal$abattoir == FALSE),], aes(x = annee, y = `valeur AMR`, group = population, color = population)) +
  geom_line(stat = "summary", fun = "mean") +
  geom_point(stat = "summary", fun = "mean", size = 2) +
  labs(title = "Baisse de la sensibilité aux antibiotiques des animaux domestiques",
       x = NULL,
       y = "Pan-sensibilité moyenne",
       color = "Population") +
  theme_minimal()

ggplot(AMR_nationale_humain, aes(x = annee, y = `valeur AMR`, group = population, color = population)) +
  geom_line(stat = "summary", fun = "mean") +
  geom_point(stat = "summary", fun = "mean", size = 2) +
  labs(title = "Augmentation de la sensibilité aux antibiotiques des populations humaines",
       x = NULL,
       y = "Pan-sensibilité moyenne",
       color = "Population") +
  theme_minimal()
```

#### 1 : Tests de tendance

Le test de Cochran Armitage est utilisé ici sur la proportion d'indivdius pan-sensibles parmi les effectifs testés. Ce test n'est approprié que lorsqu'une variable a deux niveaux et que l'autre variable est ordinale. Dans notre cas, la variable binomiale est la proportion de pan-sensible séparée en nombre de pan-sensible et nombre de résistants. La variable ordinale correspond aux années de l'étude. L'hypothèse nulle du test est qu'il n'y a pas de tendance observable dans les données.

Nous choisissons l'hypothèse alternative unilatérale car ce que nous cherchons à tester est qu'une baisse de la sensibilité apparaît au fil du temps.

```{r}
# Chargement des bibliothèques
library(dplyr)
library(DescTools)

# Définir la fonction pour effectuer le test pour une modalité donnée
perform_CochranArmitageTest <- function(data, population_modalite) {
  # Filtrer les données pour la modalité spécifiée
  matrice <- data %>% filter(population == population_modalite)
  # Calculer les valeurs Pan-sensible et Non Pan-sensible pour chaque année
  matrice <- matrice %>% mutate(pan_sensible = `valeur AMR`*`effectif AMR`/100,
                                non_pan_sensible = `effectif AMR`-pan_sensible)
  # Ordonner par année
  matrice <- matrice[order(matrice$annee), ]
  # Sélectionner les colonnes pertinentes
  matrice <- matrice[, c("annee", "pan_sensible", "non_pan_sensible")]
  # Transposer la matrice et nommer les colonnes avec les années
  matrice <- t(matrice)
  colnames(matrice) <- as.character(matrice[1, ])
  matrice <- matrice[-1, ]
  # Convertir les années en numérique
  colnames(matrice) <- as.numeric(colnames(matrice))
  # Afficher le résultat du test de Cochran-Armitage
  cat("Résultats pour la modalité", population_modalite, ":\n")
  print(CochranArmitageTest(matrice, alternative = "one.sided"))
}

# Appliquer la fonction pour chaque modalité de population
modalites_population <- c("ville", "ES-hemoculture", "ES", "EHPAD")
for (modalite in modalites_population) {
  perform_CochranArmitageTest(AMR_nationale_humain, modalite)
}

### pour les animaux :
# Définir les modalités de population pour AMR_animale_fr
modalites_population_animale <- unique(AMR_nationale_animal$population)
# Créer une liste pour stocker les résultats des tests
resultats_tests <- list()
# Boucle sur les modalités de population animale
for (modalite in modalites_population_animale) {
  resultats_tests[[modalite]] <- perform_CochranArmitageTest(AMR_nationale_animal, modalite)
}
```

### Lien à l'usage

Regression beta ou correlation sur lien entre usage et resistance à echelle nationale dans temps pour chaque population et à échelle régionale pour homme (modèles de panel ?). 
Voir s’il faut tester un décalage dans le temps (lien meilleur si prend usage N-1 ?)
Voir s’il faut tester le lien à l’usage décomposé par famille antibiotique (et non somme globale -> déterminer une famille qui jouerait plus particulièrement)
Significativité attendue et force du lien (part de variabilité expliquée par usage ? aire sous courbe ROC ?).

#### 1 : Visualisation

```{r}
usage_animal$path <- ifelse(usage_animal$annee == 2012, "Start (2012)", ifelse(usage_animal$annee == 2021, "End (2021)", "between"))

ggplot(data = usage_animal, aes(x = `valeur AMR`, y = `valeur AMU`))+
  geom_path(size = 0.8)+
  geom_point(aes(colour = path), size = 1)+
  theme_minimal()+
  theme(legend.position = "top")+
  labs(x = "Pan-S",
       y = "Usage d'antibiotiques",
       title = "L'usage d'antiotique semble avoir un effet sur la pan-sensibilité des animaux",
       caption = "Note de lecture : En 2012, les porcs avaient une valeur d'usage de 1 pour une pan-sensibilité d'environ 22.5%",
       subtitle = "Pan-sensibilité par population animale et usage d'antibiotique",
       color = "Année du test de Pan-S")+
  scale_color_manual(values = c("between" = "black", "Start (2012)" = "green", "End (2021)" = "red"))+
  facet_wrap(~population, scales = "free")

usage_humain <- usage_humain %>%
  group_by(annee, population) %>%
  mutate(AMU_moyen = mean(`valeur AMU`),
         AMR_moyen = mean(`valeur AMR`, na.rm = TRUE))

usage_humain$path <- ifelse(usage_humain$annee == 2012 & usage_humain$population == "ville", "Start", ifelse(usage_humain$annee == 2015 & usage_humain$population == "EHPAD", "Start", ifelse(usage_humain$annee == 2018 & usage_humain$population == "ES", "Start", ifelse(usage_humain$annee == 2021, "End", "between"))))

ggplot(data = usage_humain, aes(x = AMR_moyen, y = AMU_moyen))+
  geom_path(size = 0.8)+
  geom_point(aes(colour = path), size = 1)+
  theme_minimal()+
  theme(legend.position = "top")+
  labs(x = "Pan-S",
       y = "Usage d'antibiotiques",
       title = "L'usage d'antiotique a un effet sur la pan-sensibilité en EHPAD et en ville",
       caption = "Note de lecture : En 2012, un usage d'antibiotique de 140 DDD/1000 habitants/jour pour la population de ville a\nentrainé une sensibilité de 47%.",
       subtitle = "Pan-sensibilité par population humaine et usage d'antibiotique",
       color = "Année du test de Pan-S")+
  scale_color_manual(values = c("between" = "black", "Start" = "green", "End" = "red"))+
  facet_wrap(~population, scales = "free")
```
Il semble y avoir une tendance d'une résistance à la hausse pour une plus grande utilisation d'antibiotiques. Cependant, nous pouvons penser le contaire pour la population bovine. Les populations de porcs, volailles et lapins semblent avoir une tendance dans la consommation d'antibiotiques. Cette tendance s'observe aussi pour les valeurs de pan-sensibilité qui augmentent chez les porcs et les volailles. On peut faire les mêmes remarques chez les bovins, mais dans le sens inverse concernant la valeur de pan-sensibilité qui diminue au cours du temps.

Pour les populations humaines, on observe nettement que l'usage d'antibiotique entraine une baisse de la sensibilité. On observe également que les antibiotiques sont de moins en moins utilisé, et donc cela augmente la sensibilité à ceux-ci.

#### 2 : Coefficient de corrélation

```{r}
for (pop in unique(usage_humain$population)){
  usage_humain_na <- na.omit(usage_humain[which(usage_humain$population == pop),])
  print(paste(pop, round(cor(usage_humain_na$`valeur AMR`[which(usage_humain_na$population == pop)], usage_humain_na$`valeur AMU`[which(usage_humain_na$population == pop)]), 4), sep = " : "))
  rm(usage_humain_na)
}

for (pop in unique(usage_animal$population)){
  print(paste(pop, round(cor(usage_animal$`valeur AMR`[which(usage_animal$population == pop)], usage_animal$`valeur AMU`[which(usage_animal$population == pop)]), 4), sep = " : "))
}
```
L'utilisation d'antibiotique fait baisser la sensibilité pour toutes les populations, sauf la population bovine pour laquelle la corrélation est dans le sens inverse Nous observons des corrélations entre 40% et 80%, nous pouvons estimer le fait qu'un lien entre l'usage et la sensibilité est bien présent.

#### 3 : Régression bêta

Une regression bêta est privilégiée car on analyse la proportion d'animaux sensibles aux antibiotiques. Il faudra utiliser la fonction betareg du package de même nom.

```{r}
# Les hypothèses à valider avant d'utiliser la régression bêta

# Dans la régression bêta, chaque variable doit être une proportion, donc doit avoir des valeurs comprises entre 0 et 1. Or la valeur de résistance est comprise entre 0 et 100.
usage_animal <- usage_animal %>%
  mutate(`valeur AMR` = `valeur AMR`*0.01)
usage_humain <- usage_humain %>%
  filter(!is.na(`valeur AMR`)) %>%
  mutate(`valeur AMR` = `valeur AMR`*0.01)

# 1 : On vérifie que les données AMR sont hétéroscédastiques 
ggplot(data = usage_animal)+
  geom_boxplot(aes(x = `valeur AMR`, y = population))+
  scale_x_continuous(limits = c(0, 1), breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1))+
  theme_minimal()+
  labs(title = "Dispertion des valeurs AMR")

ggplot(data = usage_humain)+
  geom_boxplot(aes(x = `valeur AMR`, y = population), na.rm = TRUE)+
  scale_x_continuous(limits = c(0, 1), breaks = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1))+
  theme_minimal()+
  labs(title = "Dispertion des valeurs AMR")

# 2 : La variable de résistance doit suivre une loi bêta
# Regardons la modélisation d'une loi bêta suivant les valeurs de pan-sensibilité de chaque population

for (pop in unique(usage_animal$population)){
  mu <- mean(usage_animal$`valeur AMR`[which(usage_animal$population == pop)])
  phi <- (mu * (1 - mu)) / var(usage_animal$`valeur AMR`[which(usage_animal$population == pop)]) - 1
  a <- mu * phi
  b <- (1 - mu) * phi
  hist(usage_animal$`valeur AMR`[which(usage_animal$population == pop)], freq = FALSE, breaks = 30, main = pop, xlim = c(0, 1), xlab = "Pan-S")
  lines(density(rbeta(100, a, b)), col = 'purple', lwd = 3)
}

for (pop in unique(usage_humain$population)){
  mu <- mean(usage_humain$`valeur AMR`[which(usage_humain$population == pop)], na.rm = TRUE)
    phi <- (mu * (1 - mu)) / var(usage_humain$`valeur AMR`[which(usage_humain$population == pop)], na.rm = TRUE) - 1
  a <- mu * phi
  b <- (1 - mu) * phi
  hist(usage_humain$`valeur AMR`[which(usage_humain$population == pop)], freq = FALSE, breaks = 30, main = pop, xlim = c(0, 1), xlab = "Pan-S")
  lines(density(rbeta(100, a, b)), col = 'purple', lwd = 3)
}

# On fait la régression bêta

# Charger le package nécessaire pour les modèles de régression bêta
if(!require("betareg")){
  install.packages("betareg")
  library("betareg")
}
# Un modèle de régression par population, car l'usage n'est pas défini de la même manière selon la population
for (pop in unique(usage_animal$population)){
  usage_filtre <- usage_animal[which(usage_animal$population == pop),]
  model_beta <- betareg(data = usage_filtre, `valeur AMR` ~ `valeur AMU`, link = "logit")
  print(pop)
  print(summary(model_beta))
}
for (pop in unique(usage_humain$population)){
  usage_filtre <- usage_humain[which(usage_humain$population == pop),]
  model_beta <- betareg(data = usage_filtre, `valeur AMR` ~ log(`valeur AMU`) + annee, link = "logit")
  print(pop)
  print(summary(model_beta))
}
```

Il n'y a effectivement pas de valeurs proches de la borne supérieure, les valeurs se regroupent entre 0,1 et 0,7 pour les animaux et entre 0,3 et 0,7 pour les humains. De plus, pour chaque population, la majorité des valeurs de la variable (75%) se trouvent dans un très petit intervalle et si on ne découpe pas par population, 75% des valeurs se trouvent dans l'intervalle [0,3; 0,6]. On peut conclure quant à l'hétéroscédasticité de la variable.

Il sera également possible d'affirmer cette hypothèses avec un test d'homoscédasticité.

Nos données sont bien semblables à un échantillon de loi bêta, nous pouvons utiliser une régression bêta.

### Robustesse de l'indicateur

